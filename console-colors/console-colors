#!/bin/bash
# version 0.009

themes_dir="./console_colors"

error_exit() {
    echo "Script error: $1" >&2
    exit 1
}

usage () {
    if [[ -n "${1:-}" ]]; then
	printf "${*}\n\n" >&2
    fi
    cat >&2 << EOF
Usage: ${0} [OPTION]...

Options:
 none           List existing themes
 -a theme       Apply specified theme
 -c		Create a new theme from an existing image
 -i path        Path to the image to base the theme on
 -h             Show this help info
 -k theme       Key or theme identifier or filename to store the theme under
 -x             Apply color theme in an X terminal

Rules:

. The presence of the -i or -k options implies creation of a
  theme. The -c option is then not required.

. if -a and -k are both set, the -a option is honored.

. if -c is specified but not -i and/or -k, then the required options 
  will be queried for interactively.

. if -c and -a are both set the theme is first created and then applied

EOF
    exit 1
}

opt_apply=
opt_apply_key=
opt_create=
opt_create_key=
opt_image_path=
opt_x=

validate_arguments () {

    while getopts "a:ci:hk:x" flag; do
        case "${flag}" in
            a)
                opt_apply=true
        	opt_apply_key="${OPTARG}"
        	;;
            c)
        	opt_create=true
        	;;
            i)
        	opt_image_path="${OPTARG}"
        	opt_create=true
                [[ -e "${opt_image_path}" ]] || error_exit "image file does not exist"
        	;;
            h)
        	usage
        	;;
            k)
                opt_create_key="${OPTARG}"
        	opt_create=true
                ;;
            x)
        	opt_x=true
                ;;
            *)
        	usage
        	;;
        esac
    done
    
    shift $((${OPTIND} - 1))
}

declare -A themes

load_color_theme () {
    # load one color theme into the array
    local _key
    # x is line counter; y is non-empty line counter
    local x=y=0
    local line _colors
    local regex_pattern_comment='^\#'
    local regex_pattern_p='^P'
    local regex_pattern_color='^P[0-9A-Fa-f]{7}'
    # echo "processing file... $_path"
    _colors=()
    _key="${1##*/}"
    while read -r line; do
        # printf '%s\n' "$line"
        x=$((x+1))
        [[ "$line" ]] || continue
        [[ "$line" =~ $regex_pattern_comment ]] && continue
        y=$((y+1))
        if [[ "$line" =~ $regex_pattern_color ]]; then
            _colors+=("$BASH_REMATCH")
        else
            printf 'syntax error in line #%d: %s\n' $x "${line}"
            printf '%s\n' "contains no valid color code"
        fi
    done < "${themes_dir}"/"${key}"
    local _this_theme
    _this_theme=$(printf '%s\n' "${_colors[@]}")
    # printf 'key: %s\n' "$key"
    themes["${_key}"]=${_this_theme}
}

frugal_load_color_themes () {
    local _path _key
    while read -r _path; do
        # don't load the full theme in memory here
        # just stuff the theme name in the array and give it a value of 1
        # meaning it exists.
        # Effectively load the theme only when necessary.
        _key="${_path##*/}"
        themes["${_key}"]=1
    done < <(find $themes_dir -type f)
}

# Transform color code from format PXXXXXXX to rgb:XXXX/XXXX/XXXX
transform_color () {
    local _seq red green blue regex_pattern output
    regex_pattern='P([0-9A-Fa-f])([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})'
    input=$1
    output=
    if [[ "$input" =~ $regex_pattern ]]; then {
        _seq=${BASH_REMATCH[1]}
        red=${BASH_REMATCH[2]}
        green=${BASH_REMATCH[3]}
        blue=${BASH_REMATCH[4]}
        _seq="$(printf '%d' 0x${_seq})"
        output="--color"${_seq}"=\"rgb:"${red}${red}"/"${green}${green}"/"${blue}${blue}"\""
        # output="$(printf '--color%drgb:/%s%s/%s%s/%s%s'  $_seq $red $red $green $green $blue $blue)"
    }                                             
    else
        printf 'in transform_color: %s is not a valid color code\n' "$input" >&2
    fi
    printf '%s' ${output}
}

apply_color_theme () {
    local key="$1"
    local this_theme
    load_color_theme "${key}"
    this_theme=${themes["$key"]}
    [[ "$this_theme" == "1" ]] && {
        error_exit "$(printf 'problem loading color theme: %s' "$key")"
    }
    if [[ $opt_x ]]; then {

        local x=0
        local options=
        local option=
        local _color
        while read -r _color; do
            printf 'read _color: %s\n' "${_color}"
            transformed_color="$(transform_color ${_color})"
            options="$options"" ""$transformed_color"
            x=$((x+1))
        done <<< "$this_theme"
        eval $XTC $options
        status=$?
        #clear

    }
    else {
        
        local x=0
        while read -r _color; do
            # printf '%s\n' "$line"
            echo -en "\e]${_color}"
            x=$((x+1))
        done <<< "$this_theme"
        clear
        
    }
    fi
}

tilde_expand () {
    local input 
    local pattern1='^~/'
    local pattern2='^~[^/]+'
    local pattern3='^\$HOME'
    local _home1="/home/$USER"
    local _home2="/home"
    # tilde expansion does not work in [[ ]] -> diy
    input="$1"
    if [[ "$input" =~ $pattern1 ]]; then
        input=${input/$BASH_REMATCH/${_home1}/}
    else
        if [[ "$input" =~ $pattern2 ]]; then
            input=${input/\~/${_home2}/}
        elif [[ "$input" =~ $pattern3 ]]; then
            input="${input/${BASH_REMATCH}/${_home1}}"
        fi
    fi
    printf '%s' "$input"
}


convert_image () {
    image="$1"
    printf "%s\n" "$(convert "$image" -colors 16 -format "%c" histogram:info:)"
}

create_theme_using_palleter () {
    local _image="$opt_image_path"
    local _key="${opt_create_key}"

    [[ -z "${_key}" ]] && [[ "${opt_apply}" ]] && {
                           _key="${opt_apply_key}"
                    }

    [[ "${_key}" ]] || {
        echo "Please enter the theme identifier: "
        while read -r _key; do
            _theme=${themes["$_key"]}
            [[ "${_theme}" == 1 ]] && { 
                printf 'theme %s already exists. try again\n' "${_key}"
                continue
            }
            break
        done
        global_key="${_key}"
    }
    _theme=${themes["$_key"]}
    [[ "${_theme}" == 1  ]] && { 
        printf 'theme %s already exists\n' "${_key}"
        exit 1
    }
            
    [[ "${opt_image_path}" ]] || {
        echo "Please enter the path to the image to be sampled: "
        while read -r _image; do
            printf 'image = %s\n' "${_image}"
            _image="$(tilde_expand "${_image}")"
            [[ -e "${_image}" ]] || {
                printf 'image %s does not exist. try again\n' "${_image}"
                continue
            }
            break
        done
    }

    COL=("0" "8" "1" "9" "2" "A" "3" "B" "4" "C" "5" "D" "6" "E" "7" "F");
    x=0

    # create the new theme file

    convert_image "${_image}" | while read -r line; do
                                    line=${line#*#}; line=${line% srgb*}
                                    [[ "$line" ]] || continue # skip empty lines
                                    printf 'P%s%s\n' "${COL[$x]}" "$line" >> "$themes_dir"/"$_key"
                                    x=$((x+1))
                                done 
    # printf 'theme %s created by sampling image %s\n' "${_key}" "${_image}"
}

################################ functions for X #################################

XTC="xtermcontrol"

SettingsSave() {
   printf "\n%s\n" "Saving Current XTerm Settings:"

   FOREGROUND=`$XTC --get-fg`
   printf "%18s: %s\n" "FOREGROUND" "$FOREGROUND"

   BACKGROUND=`$XTC --get-bg`
   printf "%18s: %s\n" "BACKGROUND" "$BACKGROUND"

   CURSOR=`$XTC --get-cursor`
   printf "%18s: %s\n" "CURSOR" "$CURSOR"

   MOUSE_FOREGROUND=`$XTC --get-mouse-fg`
   printf "%18s: %s\n" "MOUSE_FOREGROUND" "$MOUSE_FOREGROUND"

   MOUSE_BACKGROUND=`$XTC --get-mouse-bg`
   printf "%18s: %s\n" "MOUSE_BACKGROUND" "$MOUSE_BACKGROUND"

   FONT=`$XTC --get-font`
   printf "%18s: %s\n" "FONT" "$FONT"

   TITLE=`$XTC --get-title`
   printf "%18s: %s\n" "TITLE" "$TITLE"

   GEOMETRY=`$XTC --get-geometry`
   printf "%18s: %s\n" "GEOMETRY" "$GEOMETRY"

   HIGHLIGHT=`$XTC --get-highlight`
   printf "%18s: %s\n" "HIGHLIGHT" "$HIGHLIGHT"

   for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
   do
      COLOR=`$XTC --get-color$i`
      COLORS=$COLORS\ $COLOR
      printf "%18s: %s\n" "COLOR$i" "$COLOR"
   done
}

SettingsRestore() {

   test -n "$FOREGROUND"       && OPT="$OPT --fg=\"$FOREGROUND\""
   test -n "$BACKGROUND"       && OPT="$OPT --bg=\"$BACKGROUND\""
   test -n "$CURSOR"           && OPT="$OPT --cursor=\"$CURSOR\""
   test -n "$MOUSE_FOREGROUND" && OPT="$OPT --mouse-fg=\"$MOUSE_FOREGROUND\""
   test -n "$MOUSE_BACKGROUND" && OPT="$OPT --mouse-bg=\"$MOUSE_BACKGROUND\""
   test -n "$FONT"             && OPT="$OPT --font=\"$FONT\""
   test -n "$TITLE"            && OPT="$OPT --title=\"$TITLE\""
   test -n "$GEOMETRY"         && OPT="$OPT --geometry=\"$GEOMETRY\""

   if test -n "$COLORS"
   then
      i=0
      for COLOR in $COLORS
      do
         OPT="$OPT --color$i=\"$COLOR\""
         i=`expr $i + 1`
      done
   fi

   eval $XTC $OPT
}

validate_arguments "$@"

frugal_load_color_themes

(( $# == 0 )) && {
    for ident in "${!themes[@]}"; do
        printf '%s\n' "$ident"
    done | sort | columns --columns=4
    exit 0
}

if [[ true == "$opt_create" ]]; then 
    create_theme_using_palleter
    # apply the new theme, but only if both creation
    # and application are requested
    if [[ "${opt_create}" ]] && [[ "${opt_apply}" ]]; then 
        apply_color_theme "${opt_apply_key}"
    fi
elif [[ true == "$opt_apply" ]]; then
    apply_color_theme "${opt_apply_key}"
fi
exit 0
 
