#!/bin/bash
# version 0.005

themes_dir="./console_colors"

error_exit() {
    echo "Script error: $1" >&2
    exit 1
}

declare -A themes

load_color_theme () {
    local  _path="$1"
    local key=${_path##*/}
    # x is line counter; y is non-empty line counter
    local x=y=0
    local line _colors
    local regex_pattern_comment='^\#'
    local regex_pattern_p='^P'
    # echo "processing file... $_path"
    _colors=()
    while read -r line; do
        # printf '%s\n' "$line"
        x=$((x+1))
        [[ "$line" ]] || continue
        [[ "$line" =~ $regex_pattern_comment ]] && continue
        y=$((y+1))
        if [[ "$line" =~ $regex_pattern_p ]]; then
            _colors+=("$line")
        else
            error_exit "syntax error"
        fi
    done < "$_path"
    local _this_theme
    _this_theme=$(printf '%s\n' "${_colors[@]}")
    # printf 'key: %s\n' "$key"
    themes["$key"]=${_this_theme}
}

load_color_themes () {
    while read -r _file; do
        load_color_theme "$_file"
    done < <(find $themes_dir -type f)
}

apply_color_theme () {
    local key="$1"
    local this_theme
    this_theme=${themes["$key"]}
    [[ "$this_theme" ]] || {
        error_exit "$(printf 'unknown color theme: %s' "$key")"
    }
    local x=0
    while read -r _color; do
        # printf '%s\n' "$line"
        x=$((x+1))
        echo -en "\e]${_color}"
    done <<< "$this_theme"
    clear
}

tilde_expand () {
    local input 
    local pattern1='^~/'
    local pattern2='^~[^/]+'
    local pattern3='^\$HOME'
    local _home1="/home/$USER"
    local _home2="/home"
    # allow spaces in the image path -> do tilde expansion yourself
    input="$1"
    if [[ "$input" =~ $pattern1 ]]; then
        input=${input/$BASH_REMATCH/${_home1}/}
    else
        if [[ "$input" =~ $pattern2 ]]; then
            input=${input/\~/${_home2}/}
        elif [[ "$input" =~ $pattern3 ]]; then
            input="${input/${BASH_REMATCH}/${_home1}}"
        fi
    fi
    printf '%s' "$input"
}


convert_image () {
    image="$1"
     printf "%s\n" "$(convert "$image" -colors 16 -format "%c" histogram:info:)"
}

create_theme_using_palleter () {
    local _image="$1"
    local _key

    echo "Please enter the theme identifier: "
    while read -r _key; do
        _theme=${themes["$_key"]}
        [[ "${_theme}" ]] && { 
            printf 'theme %s already exists. try again\n'
            continue
        }
        break
    done

    echo "Please enter the path to the image to be sampled: "
    while read -r _image; do
        printf 'image = %s\n' "${_image}"
        _image="$(tilde_expand "${_image}")"
        [[ -e "${_image}" ]] || {
            printf 'image %s does not exist. try again\n' "${_image}"
            continue
        }
        break
    done

    COL=("0" "8" "1" "9" "2" "A" "3" "B" "4" "C" "5" "D" "6" "E" "7" "F");
    x=0

    # create the new theme file

    convert_image "${_image}" | while read -r line; do
                                    line=${line#*#}; line=${line% srgb*}
                                    [[ "$line" ]] || continue # skip empty lines
                                    printf 'P%s%s\n' "${COL[$x]}" "$line" >> "$themes_dir"/"$_key"
                                    x=$((x+1))
                                done 
    # printf 'theme %s created by sampling image %s\n' "${_key}" "${_image}"
}

load_color_themes

(( $# == 0 )) && {
    for ident in "${!themes[@]}"; do
        printf '%s\n' $ident
    done | sort
    exit 0
}

# apply a color theme to the console
if [[ "$1" == '-a' ]]; then 
    apply_color_theme "$2"
fi

if [[ "$1" == '-c' ]]; then 
    create_theme_using_palleter
fi
