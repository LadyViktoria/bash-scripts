#!/bin/bash
# version 0.012

themes_dir="./console_colors"

error_exit() {
    echo "Script error: $1" >&2
    exit 1
}

usage () {
    if [[ -n "${1:-}" ]]; then
	printf "${*}\n\n" >&2
    fi
    cat >&2 << EOF
Usage: ${0} [OPTION]...

Options:
 none           List existing themes
 -a theme       Apply specified theme on the fly - without changing .Xresources
 -c		Create a new theme from an existing image
 -i path        Path to the image to base the theme on
 -h             Show this help info
 -k theme       Key or theme identifier or filename to store the theme under
 -x             Apply color theme on the fly in this X terminal emulator
 -u             Update .Xresources

Rules:

. The presence of the -i or -k options implies creation of a
  theme. The -c option is then not required.

. if -a and -k are both set, the -a option is honored.

. if -c is specified but not -i and/or -k, then the required options 
  will be queried for interactively.

. if -c and -a are both set the theme is first created and then applied

EOF
    exit 1
}
# global variables
opt_apply_on_the_fly=
opt_apply_key=
opt_create=
opt_create_key=
opt_image_path=
opt_x=
opt_update_xres="n"

# bash associative array of themes. key is theme name.
# value is 1 after quickloading all themes
declare -A themes

# theme_colors is an indexed array
# 16 console color values in format P9RRGGBB
# maybe plus 2 #RRGGBB values for X, resp. background and foreground color
declare -a theme_colors
theme_colors=()

# theme_format: 2 possible values:
#       1: console_color format - ^P9RRGGBB
#       2: .Xresources format   - either #RRGGBB or rgb:RR/GG/BB
theme_format=

color_theme_path=

# xres_theme can take the values
# xterm URxvt unknown
xres_theme=

update_xres=

validate_arguments () {
    
    local flag
    while getopts "a:ci:hk:ux" flag; do
        case "${flag}" in
            a)
                opt_apply_on_the_fly=true
        	opt_apply_key="${OPTARG}"
        	;;
            c)
        	opt_create=true
        	;;
            i)
        	opt_image_path="${OPTARG}"
        	opt_create=true
                [[ -e "${opt_image_path}" ]] || error_exit "image file does not exist"
        	;;
            h)
        	usage
        	;;
            k)
                opt_create_key="${OPTARG}"
        	opt_create=true
                ;;
            x)
        	opt_x=true
                ;;
            u)
        	opt_update_xres="y"
                ;;
            *)
        	usage
        	;;
        esac
    done
    
    shift $((${OPTIND} - 1))

    color_theme_path="$themes_dir"/"${opt_create_key:-${opt_apply_key}}"
}

on_console () {
    local _pattern='tty'
    if [[ "$(tty)" =~ ${_pattern} ]]; then
        return 0
    else
        return 1
    fi
}

load_console_color_theme () {
    # load one color theme into the global array theme_colors
    local _key
    # x is line counter; y is non-empty line counter
    local x=y=0
    local regex_pattern_comment='^\#'
    local regex_pattern_p='^P'
    local regex_pattern_color='^P[0-9A-Fa-f]{7}'
    # echo "processing file... $_path"
    _key="${1##*/}"
    while read -r line; do
        # printf '%s\n' "$line"
        x=$((x+1))
        [[ "$line" ]] || continue
        [[ "$line" =~ $regex_pattern_comment ]] && continue
        y=$((y+1))
        if [[ "$line" =~ $regex_pattern_color ]]; then
            theme_colors+=("$BASH_REMATCH")
        else
            printf 'syntax error in line #%d: %s\n' $x "${line}" >&2
            error_exit "contains no valid color code"
        fi
    done < "${color_theme_path}"
    # _this_theme=$(printf '%s\n' "${colors[@]}")
    # themes["${_key}"]=${_this_theme}
}

load_xres_color_theme () {
# convert from xres format to console-color format
    local _key
    _key="${1##*/}"
    local regex_pattern
    declare -a regex_pattern
    # index 0 - empty line
    regex_pattern=('^$')
    # index 1 - hash-commented line
    regex_pattern+=('^[ ]+#')
    # index 2 - xres-commented-line
    regex_pattern+=('^!')
    # index 3 - has xterm
    regex_pattern+=('xterm')
    # index 4 - has URxvt
    regex_pattern+=('URxvt')
    # index 5 - has colorx:
    regex_pattern+=('(color[0-9]:)' )
    # index 6 - has colorxx:
    regex_pattern+=('(color[0-9]{2}:)')
    # index 7 - has hash color
    regex_pattern+=('#([0-9a-fA-F]{6})')
    # index 8 - has hash rgb/xx/xx/xx color
    regex_pattern+=('rgb:([0-9a-fA-F]{2})/([0-9a-fA-F]{2})/([0-9a-fA-F]{2})')
    # index 9 - has background:
    regex_pattern+=('(background:)')
    # index 10 - has foreground:
    regex_pattern+=('(foreground:)')
                     
    local lc=0 # line counter
    local _line
    local _errors=0
    local xres_chances=0
    
    # store line attributes in an array.
    # the index in the array corresponds to the regex_patter_number
    # i.e if the line has pattern 8, hash_attribs[8] will contain the match(es)
    local line_attribs file_attribs
    declare -a line_attribs file_attribs

    file_attribs=()
    local i 
    for i in  0 1 2 3 4; do
        file_attribs[$i]=0
    done
    local _theme
    declare -a _theme
    _theme=()

    local MAPFILE
    declare -a MAPFILE
    MAPFILE=()
    local _file="$1"
    mapfile -t -n 0 MAPFILE < <(cat "${color_theme_path}")

    for _line in "${MAPFILE[@]}"; do
        # printf -- '--->%s\n' "${_line}" >&2
        lc=$((lc+1))
        line_attribs=()
        local i 
        for i in  0 1 2 3 4; do
            line_attribs[$i]=0
            file_attribs[$i]=0
        done

        for i in 0 1 2 3 9 10 4; do
            if [[ "${_line}" =~ ${regex_pattern[$i]} ]]; then
                file_attribs[$i]=$((file_attribs[$i]+1))
                line_attribs[$i]=$((line_attribs[$i]+1))
            fi
        done

        for i in 7 8 5 6; do
            if [[ "${_line}" =~ ${regex_pattern[$i]} ]]; then
                if (( $i == 8 )); then
                    line_attribs[$i]="${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]}"
                else
                    line_attribs[$i]="${BASH_REMATCH[1]}"
                fi
            fi
        done

        # evaluate line attributes here

        local _attrib _color_index _color _rgb color_index_code
        # color lines: colorx
        if [[ "${line_attribs[5]}" ]]; then
            _attrib="${line_attribs[5]}"
            _color_index="${_attrib:5:1}"
            if [[ "${line_attribs[7]}" ]]; then
                _attrib="${line_attribs[7]}"
                _color=${_attrib}
                theme_colors[${_color_index}]="P"${_color_index}${_color}
                # default bg and fg
                _color="#"${_color}
                [[ "${_color_index}" == 0 ]] && theme_colors[16]=${theme_colors[16]:-${_color}}
                [[ "${_color_index}" == 7 ]] && theme_colors[17]=${theme_colors[17]:-${_color}}
            elif [[ "${line_attribs[8]}" ]]; then
                _attrib="${line_attribs[8]}"
                _rgb=(${_attrib})
                _color=${_rgb[0]}${_rgb[1]}${_rgb[2]}
                theme_colors[${_color_index}]="P"${_color_index}${_color}
                default bg and fg
                _color="#"${_color}
                [[ "${_color_index}" == 0 ]] && theme_colors[16]=${theme_colors[16]:-${_color}}
                [[ "${_color_index}" == 7 ]] && theme_colors[17]=${theme_colors[17]:-${_color}}
            else
                printf 'syntax error: line %d has invalid color definition\n' ${lc} >&2
                errors=$((errors+1))
            fi
        fi

        # color lines: colorxx
        if [[ "${line_attribs[6]}" ]]; then
            _attrib="${line_attribs[6]}"
            _color_index="${_attrib:5:2}"
            _color_index_code="$(printf '%x' ${_color_index} | tr [:lower:] [:upper:])"
            if [[ "${line_attribs[7]}" ]]; then
                _attrib="${line_attribs[7]}"
                _color=${_attrib}
                theme_colors[${_color_index}]="P"${_color_index_code}${_color}
            elif [[ "${line_attribs[8]}" ]]; then
                _attrib="${line_attribs[8]}"
                _rgb=(${_attrib})
                _color=${_rgb[0]}${_rgb[1]}${_rgb[2]}
                theme_colors[${_color_index}]="P"${_color_index_code}${_color}
            else
                printf 'syntax error: line %d has invalid color definition\n' ${lc} >&2
                errors=$((errors+1))
            fi
        fi

        # background color
        if [[ "${line_attribs[9]}" ]]; then
            if [[ "${line_attribs[7]}" ]]; then
                _attrib="${line_attribs[7]}"
                _color=${_attrib}
                theme_colors[16]="#"${_color}
            elif [[ "${line_attribs[8]}" ]]; then
                _attrib="${line_attribs[8]}"
                _rgb=(${_attrib})
                _color="${_rgb[0]}/${_rgb[1]}/${_rgb[2]}"
                theme_colors[16]="#"${_color}
            else
                printf 'syntax error: line %d has invalid color definition\n' ${lc}
                errors=$((errors+1))
            fi
        fi

        # foreground color
        if [[ "${line_attribs[10]}" ]]; then
            if [[ "${line_attribs[7]}" ]]; then
                _attrib="${line_attribs[7]}"
                _color=${_attrib}
                theme_colors[17]="#"${_color}
            elif [[ "${line_attribs[8]}" ]]; then
                _attrib="${line_attribs[8]}"
                _rgb=(${_attrib})
                _color="${_rgb[0]}/${_rgb[1]}/${_rgb[2]}"
                theme_colors[17]="#"${_color}
            else
                printf 'syntax error: line %d has invalid color definition\n' ${lc}
                errors=$((errors+1))
            fi
        fi

    done
    # evaluate global attributes
    if (( ${file_attribs[1]} > 0 )) && (( ${file_attribs[2]} > 0 )); then
        printf '%s\n' "input file contains a mix of comment syntaxes" >&2
    fi
    
    if (( ${file_attribs[3]} > 0 )) && (( ${file_attribs[4]} > 0 )); then
        printf '%s\n' "input file contains a mix of xterm and urxt attributes" >&2
        errors=$((errors+1))
    fi
    
    xres_theme="unknown"
    (( ${file_attribs[4]} > 0 )) && xres_theme="URxvt"
    (( ${file_attribs[3]} > 0 )) && xres_theme="xterm"

    if (( ${_errors} > 0 )); then
        printf '%d errors encountered while parsing file %s\n' $errors >&2
        exit 1
    fi
}

load_color_theme () {
    # determine format of the theme file: console_colors or xres format?
    # sets global variable theme_format
    local _key
    _key="${1##*/}"
    local _pattern 
    _pattern='^P[0-9a-fA-F]{7}'
    local -i _count
    _count=$(grep -c -E ${_pattern} "${themes_dir}/${_key}")
    if (( _count == 16 )); then
        theme_format=1
        load_console_color_theme "${_key}"
    elif (( _count > 0 )) && (( _count < 16 )); then
        local _errmsg=$(printf 'theme %s is not complete: 
only %d out of 16 color definitions are  present' "${_key}" ${_count})
        error_exit "${_errmsg}"
    elif (( _count > 16 )); then
        local _errmsg=$(printf 'theme %s contains %d color definitions
while 16 is the maximum allowed for this format' "${_key}" ${_count})
        error_exit "${_errmsg}"
    else
        theme_format=2
        load_xres_color_theme "${_key}"
    fi

    # printf '%s ' "${theme_colors[@]}" >&2
    # printf '\n' >&2
    # printf 'the theme has %d colors defined\n' ${#theme_colors[@]} >&2
    
}

quickload_color_themes () {
    local _path _key
    while read -r _path; do
        # don't load the full theme in memory here
        # just stuff the theme name in the array and give it a value of 1
        # meaning it exists.
        # Effectively load the theme only when necessary.
        _key="${_path##*/}"
        themes["${_key}"]="1"
    done < <(find $themes_dir -type f)
}

# Transform color code from format PXXXXXXX to rgb:XXXX/XXXX/XXXX
console_color_to_device_independent_rgb () {
    local _seq _red _green _blue _regex_pattern _input _output
    _regex_pattern='P([0-9A-Fa-f])([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})'
    _input=$1
    _output=
    if [[ "${_input}" =~ ${_regex_pattern} ]]; then {
        _seq=${BASH_REMATCH[1]}
        _red=${BASH_REMATCH[2]}
        _green=${BASH_REMATCH[3]}
        _blue=${BASH_REMATCH[4]}
        _seq="$(printf '%d' 0x${_seq})"
        _output="--color"${_seq}"=\"rgb:"${_red}${_red}"/"${_green}${_green}"/"${_blue}${_blue}"\""
    }                                             
    else
        local _error_msg
        _error_msg="$(printf 'console_color_to_device_independent_rgb: %s is not a valid color code\n' "${_input}")"
        error_exit ${_error_msg} 
    fi
    printf '%s' ${_output}
}

# Transform color code from format #RRGGBB to rgb:XXXX/XXXX/XXXX
hash_rgb_color_to_device_independend_rgb () {
    local _seq _red _green _blue _regex_pattern _input _output
    _regex_pattern='#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})'
    _input=$1
    _output=
    if [[ "${_input}" =~ ${_regex_pattern} ]]; then {
        _red=${BASH_REMATCH[1]}
        _green=${BASH_REMATCH[2]}
        _blue=${BASH_REMATCH[3]}
        _output="--color=\"rgb:"${_red}${_red}"/"${_green}${_green}"/"${_blue}${_blue}"\""
    }                                             
    else
        local _error_msg
        _error_msg="$(printf 'hash_rgb_color_to_device_independent_rgb: %s is not a valid color code\n' "${_input}")"
        error_exit ${_error_msg} 
    fi
    printf '%s' ${_output}
}

# Transform color code from format rgb:XX/XX/XX to rgb:XXXX/XXXX/XXXX
rgb_color_to_device_independent_rgb () {
    local _seq _red _green _blue _regex_pattern _input _output
    _regex_pattern='rgb:([0-9a-fA-F]{2})/([0-9a-fA-F]{2})/([0-9a-fA-F]{2})'
    _input=$1
    _output=
    if [[ "${_input}" =~ ${_regex_pattern} ]]; then {
        _red=${BASH_REMATCH[1]}
        _green=${BASH_REMATCH[2]}
        _blue=${BASH_REMATCH[3]}
        _output="--color=\"rgb:"${_red}${_red}"/"${_green}${_green}"/"${_blue}${_blue}"\""
    }                                             
    else
        local _error_msg
        _error_msg="$(printf 'Rrgb_color_to_device_independent_rgb: %s is not a valid color code\n' "$input")"
        error_exit ${_error_msg} 
    fi
    printf '%s' ${_output}
}

update_xresources () {

    local XRESOURCES
    declare -a XRESOURCES
    local _Xresources="$HOME/.Xresources"
    [[ -e ${_Xresources} ]] || {
        touch ${_Xresources}
        (( $? != 0 )) && error_exit "can not create ${_Xresources}"
    }
    [[ -w ${_Xresources} ]] && chmod +w ${_Xresources}
    (( $? != 0 )) && error_exit "can not write to  ${_Xresources}"
    # read $HOME/.Xresources into memory
    mapfile -t -n 0 XRESOURCES < <(cat ${_Xresources})
    

    # read the color theme file into memory
    
    local COLORTHEME
    declare -a COLORTHEME
    mapfile -t -n 0 COLORTHEME < <(cat "${color_theme_path}")

    # for every line in COLORTHEME that is not a comment line
    # search the line in XRESOURCES which is not a comment line and
    # which starts with the firs word from the COLORTHEME line.
    # when you find such lines, comment them
    #
    # Append the lines from COLORTHEME to XRESOURCES

    local i j xres_line theme_line first_word_xres first_word_theme
    declare -i i j



    for ((i=0; i<${#XRESOURCES[@]}; i++)); do
        xres_line="{XRESOURCES[$i]}"
        if [[ "${xres_line}" == '^$' ]]; then continue; fi
        if [[ "${xres_line}" == '[ ]*!' ]]; then continue; fi
        if [[ "!" == ${xres_line:0:1} ]]; then continue; fi
        if [[ "${xres_line}" == '(^[:alnum:]+\b)' ]]; then 
            first_word_xres=${BASH_REMATCH}
        fi
        
        for ((j=0; j<${#COLORTHEME[@]})); do
            theme_line="${COLOR_THEME[$j}"
            if [[ "${theme_line}" == '^$' ]]; then continue; fi
            if [[ "${theme_line}" == '[ ]*!' ]]; then continue; fi
            if [[ "${xres_line}" == '(^[:alnum:]+\b)' ]]; then
                first_word_theme=${BASH_REMATCH}
                if [[ $first_word_xres == $first_word_theme ]]; then
                    XRESOURCES[$i]="! ${xres_line}"
                    continue
                fi
            fi
        done
    done
}

apply_color_theme_on_the_fly () {
    # $1: color theme key
    # $2: y/n flag to update xresources or not
    local _key="$1"
    local _update_xres=$2
    if [[ "${themes["$_key"]}" != "1" ]]; then
        error_exit "$(printf 'theme \"%s\" does not exist' "${_key}")"
    fi
    (( ${#theme_colors[@]} == 0 )) && load_color_theme "${_key}"    
    if [[ $opt_x ]]; then 
        
        local _color _transformed_color _option 
        local _transformed_colors _options
        declare -a _transformed_colors _options
        local _regex_pattern
        _regex_pattern='#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})'
        _transformed_colors=()
        _options=()
        local x
        # 16 base colors, bg and fg present depending on theme_format
        # if bg and fg not defined, default to one of the base colors - prefer dark bg
        # WARNING: bg abd fg are in hash_rgb format or rgb:rr/gg/bb format
        local _max
        if (( theme_format==1 )); then _max=16; else _max=18; fi
        for ((x=0; x<${_max}; x++)); do
            if (( x<16)); then
                _transformed_color=$(console_color_to_device_independent_rgb ${theme_colors[$x]})
                _transformedtheme_colors+=(${_transformed_color})
                _option="$_transformed_color"
                _options+=(${_option})
            else
                _color=${theme_colors[$x]}
                if [[ ${_color} =~ ${_regex_pattern} ]]; then
                    _transformed_color=$(hash_rgb_color_to_device_independend_rgb ${_color})
                else
                    _transformed_color=$(rgb_color_to_device_independend_rgb ${_color})
                fi
                _option=(${_transformed_color})
                (( x == 16 )) && _option=${_option/--color/--bg}
                (( x == 17 )) && _option=${_option/--color/--fg}
                _options+=(${_option})
            fi
        done

        # update .Xresources if requested
        if [[ "y" == "$_update_xres" ]]; then
            update_xresources
        fi

        if [[ "$TERM" =~ 'xterm' ]]; then

        
            eval $XTC "$(printf '%s ' "${_options[@]}" )"
            local _return_code=$?
            (( ${_return_code} != 0 )) &&
            printf '%s\n' "$XTC returned ${_return_code}" >&2
           
        else
            printf 'Changing theme on the fly for terminal emulator %s is not implemented yet\n' $TERM >&2
            return 1
        fi

    else
        
        # activate on the console - only if on a console
        if on_console; then
            local _color
            for _color in "${theme_colors[@]}"; do 
                echo -en "\e]${_color}"
            done
            clear
        else
            error_exit "You are not on a console. Can not apply the color theme."
        fi

    fi
}

tilde_expand () {
    local input 
    local pattern1='^~/'
    local pattern2='^~[^/]+'
    local pattern3='^\$HOME'
    local _home1="/home/$USER"
    local _home2="/home"
    # tilde expansion does not work in [[ ]] -> diy
    input="$1"
    if [[ "$input" =~ $pattern1 ]]; then
        input=${input/$BASH_REMATCH/${_home1}/}
    else
        if [[ "$input" =~ $pattern2 ]]; then
            input=${input/\~/${_home2}/}
        elif [[ "$input" =~ $pattern3 ]]; then
            input="${input/${BASH_REMATCH}/${_home1}}"
        fi
    fi
    printf '%s' "$input"
}


convert_image () {
    image="$1"
    printf "%s\n" "$(convert "$image" -colors 16 -format "%c" histogram:info:)"
}

create_theme_using_palleter () {
    local _image="$opt_image_path"
    local _key="${opt_create_key}"

    [[ -z "${_key}" ]] && [[ "${opt_apply_on_the_fly}" ]] && {
                           _key="${opt_apply_on_the_fly_key}"
                    }

    [[ "${_key}" ]] || {
        echo "Please enter the theme identifier: "
        while read -r _key; do
            _theme=${themes["$_key"]}
            [[ "${_theme}" == "1" ]] && { 
                printf 'theme %s already exists. try again\n' "${_key}"
                continue
            }
            break
        done
        global_key="${_key}"
    }
    _theme=${themes["$_key"]}
    [[ "${_theme}" == "1" ]] && { 
        printf 'theme %s already exists\n' "${_key}"
        exit 1
    }
            
    [[ "${opt_image_path}" ]] || {
        echo "Please enter the path to the image to be sampled: "
        while read -r _image; do
            printf 'image = %s\n' "${_image}"
            _image="$(tilde_expand "${_image}")"
            [[ -e "${_image}" ]] || {
                printf 'image %s does not exist. try again\n' "${_image}"
                continue
            }
            break
        done
    }

    COL=("0" "8" "1" "9" "2" "A" "3" "B" "4" "C" "5" "D" "6" "E" "7" "F");
    x=0

    # create the new theme file

    convert_image "${_image}" | while read -r line; do
                                    line=${line#*#}; line=${line% srgb*}
                                    [[ "$line" ]] || continue # skip empty lines
                                    printf 'P%s%s\n' "${COL[$x]}" "$line" >> "$themes_dir"/"$_key"
                                    x=$((x+1))
                                done 
    # printf 'theme %s created by sampling image %s\n' "${_key}" "${_image}"
}

update_xresources () {

    local XRESOURCES
    declare -a XRESOURCES
    local _Xresources="$HOME/.Xresources"
    [[ -e ${_Xresources} ]] || {
        touch ${_Xresources}
        (( $? != 0 )) && error_exit "can not create ${_Xresources}"
    }
    [[ -w ${_Xresources} ]] && chmod +w ${_Xresources}
    (( $? != 0 )) && error_exit "can not write to  ${_Xresources}"
    # read $HOME/.Xresources into memory
    mapfile -t -n 0 XRESOURCES < <(cat ${_Xresources})
    

    # read the color theme file into memory
    
    local COLORTHEME
    declare -a COLORTHEME
    mapfile -t -n 0 COLORTHEME < <(cat ${color_theme_path})

    printf '%s\n' "${COLORTHEME[@]}"

    # for every line in COLORTHEME that is not a comment line
    # search the line in XRESOURCES which is not a comment line and
    # which starts with the firs word from the COLORTHEME line.
    # when you find such lines, comment them
    #
    # Append the lines from COLORTHEME to XRESOURCES

    local i j xres_line theme_line first_word_xres first_word_theme
    declare -i i j

    local pattern1 pattern2 pattern3

    pattern1='^$'
    pattern2='^[ ]*!'
    pattern3='^([A-Za-z0-9*]+:)'

    local modified_flag=

    for ((i=0; i<${#XRESOURCES[@]}; i++)); do
        xres_line="${XRESOURCES[$i]}"

        printf -- '--->%s\n' "${xres_line}"

        if [[ "${xres_line}" =~ $pattern1 ]]; then continue; fi
        if [[ "${xres_line}" =~ $pattern2 ]]; then continue; fi
        if [[ "${xres_line}" =~ $pattern3 ]]; then 
            if [[ "!" == "${xres_line:0:1}" ]]; then continue; fi
            first_word_xres=${BASH_REMATCH}
                
                
            for ((j=0; j<${#COLORTHEME[@]}; j++)); do
                theme_line="${COLORTHEME[$j]}"
                if [[ "${theme_line}" =~ $pattern1 ]]; then continue; fi
                if [[ "${theme_line}" =~ $pattern2 ]]; then continue; fi
                if [[ "${theme_line}" =~ $pattern3 ]]; then
                    first_word_theme=${BASH_REMATCH}
                    
                    printf -- '\n--> %s\n' "match"
                    
                    if [[ $first_word_xres == $first_word_theme ]]; then
                        XRESOURCES[$i]="! ${xres_line}"
                        modified_flag=true
                        continue
                    fi
                fi
            done
            
        fi
    done

    # Write the new .Xresources file to a tempfile
    local TEMPFILE=$(mktemp $HOME/tmp/console_colors.XXXXXX)
    [[ $TEMPFILE ]] || error_exit "Could not create temp file"

    for xres_line in "${XRESOURCES[@]}"; do
        printf '%s\n' "$xres_line" >> ${TEMPFILE}
    done
    # append the new color_theme
    
    # append the new xres config snippet
    printf '%s\n' "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >> ${TEMPFILE}
    printf '%s\n' "!! Added by console_colors !!" >> ${TEMPFILE}
    printf '%s\n' "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >> ${TEMPFILE}

    for theme_line in "${COLORTHEME[@]}"; do
        printf '%s\n' "$theme_line" >> ${TEMPFILE}
    done
    set -e
    
    i=0
    while [[ -e "${_Xresources}.bak.$i" ]]; do
        i=$((i+1))
    done

    [[ -s $TEMPFILE ]] && {
        cp ${_Xresources} "${_Xresources}.bak.$i"
        mv ${TEMPFILE} ${_Xresources}
    }
    set +e
    printf '%s\n' "updated ${_Xresources}"
}

################################ functions for X #################################

XTC="xtermcontrol"

validate_arguments "$@"

quickload_color_themes

(( $# == 0 )) && {
    for ident in "${!themes[@]}"; do
        printf '%s\n' "$ident"
    done | sort | columns --columns=4

    printf '%s\n\n' "show all existing color themes..."

    
    for ident in "${!themes[@]}"; do
        
        if apply_color_theme_on_the_fly "$ident" "n"; then
            printf '\t%s' $ident
            env-info
            sleep 2
        fi
    done

    exit 0
}

if [[ true == "$opt_create" ]]; then 
    create_theme_using_palleter
    # apply the new theme, but only if both creation
    # and application are requested
    if [[ "${opt_create}" ]] && [[ "${opt_apply_on_the_fly}" ]]; then 
        apply_color_theme_on_the_fly "${opt_apply_key}" "$opt_update_xres"
        env-info
    fi
elif [[ true == ${opt_apply_on_the_fly} ]]; then
    if apply_color_theme_on_the_fly "${opt_apply_key}" "$opt_update_xres"; then
        env-info
    fi
fi
exit 0
 
